#!/usr/bin/env bash

# Anthon Open Source Community 
# Pinyin Completion Hook for Bash-Completion

# Detect bash-completion
if ! declare -F _comp_compgen__call_builtin &>/dev/null; then
    echo "No function _comp_compgen__call_builtin found. Please install bash-completion first."
    exit 1
fi

# Backup the original function
eval "function __bak_comp_compgen__call_builtin() { $(declare -f _comp_compgen__call_builtin | tail -n +2) }"


_comp_compgen__call_builtin() {
    __bak_comp_compgen__call_builtin "$@"
    local original_result=$?
    
    # Only add pinyin completion for file/directory completions
    local is_file_completion=false
    local compgen_args=("$@")
    
    # Check for file completion indicators
    for arg in "${compgen_args[@]}"; do
        case "$arg" in
            -f|-d|-A|file|directory)
                is_file_completion=true
                break
                ;;
        esac
    done
    
    # If this looks like file completion, add pinyin matches
    if [[ "$is_file_completion" == true ]]; then
        _add_completion "$@"
    fi
    
    return $original_result
}

# Function to add completion results
_add_completion() {
    # cur: bash-completion's working value for the current word.
    local cur

    eval "cur=${_cur}"
    # origin_cur: the user's raw buffer text before any expansion
    # including quotes or ~user prefixes. in other word, "snapshot".
    local orig_cur="$cur"
    # stripped_orig: an editable copy of orig_cur
    # used to compute orig_dirpart without mutating the original text.
    local stripped_orig="$orig_cur"
    local orig_dirpart=""
    if [[ "$stripped_orig" == "'"* || "$stripped_orig" == '"'* ]]; then
        stripped_orig="${stripped_orig:1}"
    fi
    if [[ "$stripped_orig" == */* ]]; then
        orig_dirpart="${stripped_orig%/*}"
    fi
    if [[ "$orig_dirpart" == "." && "${stripped_orig:0:2}" != "./" ]]; then
        orig_dirpart=""
    fi
    
    # Check if we have the necessary variables
    if [[ -z "${_cur-}" ]] || [[ -z "${_var-}" ]]; then
        return
    fi
    
    local var_name="$_var"
    
    # Skip empty
    [[ -z "$cur" ]] && return

    # perform bash-completion's normal expansions.
    _expand || return 0

    local dirpart basepart
    if [[ "${cur:0:1}" == "'" || "${cur:0:1}" == "\"" ]]; then
        dirpart="$(dirname -- "${cur:1}")"
        basepart="$(basename -- "${cur:1}")"
    else
        dirpart="$(dirname -- "$cur")"
        basepart="$(basename -- "$cur")"
    fi
    
    [[ "$dirpart" == "." && "${cur:0:2}" != "./" ]] && dirpart=""
    
    local savedPWD="$PWD"
    local resolved_dir
    local compgen_opts=(-f)
    
    local is_dir_only=false
    for arg in "$@"; do
        if [[ "$arg" == "-d" ]]; then
            is_dir_only=true
            compgen_opts=(-d)
            break
        fi
    done
    
    if [[ -n "$dirpart" ]]; then
        # Resolve the working directory for compgen use realpath, but remember
        # the original textual prefix so completions can stay aligned with what the user typed.
        resolved_dir="$(realpath -- "$dirpart" 2>/dev/null)"
        if [[ -d "$resolved_dir" ]]; then
            cd -- "$resolved_dir" 2>/dev/null || return
        else
            cd "$savedPWD" || return
            return
        fi
    fi

    # Kernel
    local -a pinyin_matched
    if [[ "$is_dir_only" == true ]]; then
        mapfile -t pinyin_matched < <(
            compgen -d -- 2>/dev/null |
            bash-pinyin-completion-rs "$basepart" 2>/dev/null
        )
    else
        mapfile -t pinyin_matched < <(
            compgen -f -- 2>/dev/null |
            bash-pinyin-completion-rs "$basepart" 2>/dev/null
        )
    fi
    
    # Restore directory
    cd "$savedPWD" || return
    
    if [[ ${#pinyin_matched[@]} -gt 0 ]]; then
        local display_dirpart="$dirpart"
        if [[ -n "$orig_dirpart" ]]; then
            # When the user typed something like ~user/src, prefer their original prefix for display
            # instead of the realpath directory we temp into.
            # "snapshot" we saved before comes in handy here.
            display_dirpart="$orig_dirpart"
        fi
        if [[ -n "$display_dirpart" ]]; then
            local sep="/"
            [[ "$display_dirpart" == "/" ]] && sep=""
            for i in "${!pinyin_matched[@]}"; do
                pinyin_matched[$i]="${display_dirpart}${sep}${pinyin_matched[$i]}"
            done
        fi

        local orig_check="$orig_cur"
        if [[ "$orig_check" == "'"* || "$orig_check" == '"'* ]]; then
            orig_check="${orig_check:1}"
        fi
        if [[ "$orig_check" == ~* ]]; then
            # Map the tilde-prefix the user entered back onto the filesystem
            # path produced by compgen so the completion output preserves the symbolic form.
            local tilde_prefix="${orig_check%%/*}"
            local expanded_prefix=""
            if [[ "$tilde_prefix" == "~" ]]; then
                expanded_prefix="$HOME"
            elif [[ "$tilde_prefix" == ~+ ]]; then
                expanded_prefix="$PWD"
            elif [[ "$tilde_prefix" == ~- ]]; then
                expanded_prefix="${OLDPWD-}"
            else
                local tilde_user="${tilde_prefix:1}"
                if [[ -n "$tilde_user" ]]; then
                    # Find the user from passwd.
                    expanded_prefix="$(getent passwd "$tilde_user" 2>/dev/null | cut -d: -f6)"
                fi
            fi
            if [[ -n "$expanded_prefix" ]]; then
                for i in "${!pinyin_matched[@]}"; do
                    if [[ "${pinyin_matched[$i]}" == "$expanded_prefix" ]]; then
                        # Exact home directory.
                        pinyin_matched[$i]="$tilde_prefix"
                    elif [[ "${pinyin_matched[$i]}" == "$expanded_prefix"/* ]]; then
                        local suffix="${pinyin_matched[$i]#"$expanded_prefix/"}"
                        # Join path under the user home.
                        pinyin_matched[$i]="$tilde_prefix/$suffix"
                    fi
                done
            fi
        fi

        local current_results_var="current_results"
        eval "local -a $current_results_var=(\"\${$var_name[@]}\")"
        
        # Merge results and remove duplicates
        local -a all_results
        eval "all_results=(\"\${$current_results_var[@]}\" \"\${pinyin_matched[@]}\")"

        declare -A seen
        local -a unique_results=()
        for item in "${all_results[@]}"; do
            if [[ -z "${seen[$item]}" ]]; then
                seen["$item"]=1
                unique_results+=("$item")
            fi
        done

        eval "$var_name=(\"\${unique_results[@]}\")"
    fi
}
